<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chaos Control ‚Äî Smart Scheduler v3.3</title>
  <link rel="stylesheet" href="styles.css"/>

  <!-- React from CDN (no build) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <script type="text/babel">
    const {useState,useEffect,useMemo,useRef} = React;

    /* ---------- helpers ---------- */
    const pad=(n)=>String(n).padStart(2,"0");
    const minutes=(h,m=0)=>h*60+m;
    const addMinutes=(d,m)=>{const x=new Date(d); x.setMinutes(x.getMinutes()+m); return x;};
    const startOfDay=(d)=>{const x=new Date(d); x.setHours(0,0,0,0); return x;};
    const endOfDay=(d)=>{const x=new Date(d); x.setHours(23,59,59,999); return x;};
    const startOfWeek=(d,ws=1)=>{const x=new Date(d); const day=(x.getDay()+7-ws)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x;};
    const toKey=(d)=>`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    const parseKey=(s)=>{const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d);};
    const humanTime=(d)=>`${pad(d.getHours())}:${pad(d.getMinutes())}`;
    const endTime=(s,dur)=>addMinutes(s,dur);
    const uid=()=> (crypto?.randomUUID? crypto.randomUUID() : Math.random().toString(36).slice(2));

    /* ---------- storage ---------- */
    const LS_TASKS="cc_tasks_v33";
    const LS_BLOCKS="cc_blocks_v33";
    const LS_SETTINGS="cc_settings_v33";
    const load=(k,fb)=>{try{const raw=localStorage.getItem(k);return raw?JSON.parse(raw):fb;}catch{return fb;}};
    const save=(k,v)=>{try{localStorage.setItem(k,JSON.stringify(v));}catch{}};

    /* ---------- DEEP MIGRATION (scans all keys) ---------- */
    function migrateIfEmpty(){
      const hasAny=(arr)=>Array.isArray(arr)&&arr.length>0;
      const looksLikeTask=(x)=>x&&typeof x==="object"&&"title" in x&&("duration" in x||"priority" in x);
      const looksLikeBlock=(x)=>x&&typeof x==="object"&&("start" in x||"day" in x||"duration" in x);
      const looksLikeSettings=(x)=>x&&typeof x==="object"&&("workStartMins" in x||"workEndMins" in x||"theme" in x);

      let currTasks=load(LS_TASKS,[]), currBlocks=load(LS_BLOCKS,[]), currSettings=load(LS_SETTINGS,null);
      if(hasAny(currTasks) || hasAny(currBlocks) || currSettings){
        console.log("‚ÑπÔ∏è Current storage has data. Migration not needed.");
        return;
      }

      let importedTasks=[], importedBlocks=[], importedSettings=null;
      for(let i=0;i<localStorage.length;i++){
        const k=localStorage.key(i); if(!k) continue;
        try{
          const raw=localStorage.getItem(k); if(!raw) continue;
          const v=JSON.parse(raw);
          if(!hasAny(importedTasks) && Array.isArray(v) && v.some(looksLikeTask)) importedTasks=v;
          else if(!hasAny(importedBlocks) && Array.isArray(v) && v.some(looksLikeBlock)) importedBlocks=v;
          else if(!importedSettings && looksLikeSettings(v)) importedSettings=v;
        }catch{}
      }
      let migrated=false;
      if(!hasAny(currTasks) && hasAny(importedTasks)){ save(LS_TASKS,importedTasks); migrated=true; }
      if(!hasAny(currBlocks) && hasAny(importedBlocks)){ save(LS_BLOCKS,importedBlocks); migrated=true; }
      if(!currSettings && importedSettings){ save(LS_SETTINGS,importedSettings); migrated=true; }
      console.log(migrated? "‚úÖ Deep migration imported data from older keys." : "‚ÑπÔ∏è No older data found to migrate.");
    }

    /* ---------- holidays (AB) ---------- */
    function easterDate(year){const a=year%19,b=Math.floor(year/100),c=year%100,d=Math.floor(b/4),e=b%4,f=Math.floor((b+8)/25),g=Math.floor((b-f+1)/3),h=(19*a+b-d-g+15)%30,i=Math.floor(c/4),k=c%4,l=(32+2*e+2*i-h-k)%7,m=Math.floor((a+11*h+22*l)/451),mo=Math.floor((h+l-7*m+114)/31),da=((h+l-7*m+114)%31)+1;return new Date(year,mo-1,da);}
    function nthDowOfMonth(y,m,dow,n){const f=new Date(y,m,1),o=(dow-f.getDay()+7)%7;return new Date(y,m,1+o+(n-1)*7);}
    function lastDowBefore(y,m,lastDay,dow){const d=new Date(y,m,lastDay); while(d.getDay()!==dow) d.setDate(d.getDate()-1); return d;}
    function abHolidaysMap(){
      const y=new Date().getFullYear();
      const list=(yr)=>[
        {d:new Date(yr,0,1), n:"New Year's Day"},
        {d:nthDowOfMonth(yr,1,1,3), n:"Family Day"},
        {d:(()=>{const e=easterDate(yr); const g=new Date(e); g.setDate(e.getDate()-2); return g;})(), n:"Good Friday"},
        {d:lastDowBefore(yr,4,24,1), n:"Victoria Day"},
        {d:new Date(yr,6,1), n:"Canada Day"},
        {d:nthDowOfMonth(yr,8,1,1), n:"Labour Day"},
        {d:new Date(yr,8,30), n:"Truth and Reconciliation"},
        {d:nthDowOfMonth(yr,9,1,2), n:"Thanksgiving"},
        {d:new Date(yr,10,11), n:"Remembrance Day"},
        {d:new Date(yr,11,25), n:"Christmas Day"},
        {d:new Date(yr,11,26), n:"Boxing Day"},
      ];
      const all=[...list(y),...list(y+1)]; const m=new Map();
      all.forEach(h=>m.set(toKey(h.d),h.n)); return m;
    }

    /* ---------- snark ---------- */
    const SNARK_MILD=[
      "Well look at you, functioning adult of the year.",
      "Everything done? I‚Äôm as shocked as you are.",
      "Achievement unlocked: Did the bare minimum, but in style.",
      "The productivity gods are appeased‚Ä¶ for now.",
      "Chaos temporarily under control. Carry on."
    ];
    const SNARK_CHAOS=[
      "Everything done? Who replaced you with someone responsible?",
      "You finished *everything*? Screenshot before reality reloads.",
      "Task list annihilated. Chaos 0 ‚Äî You 1.",
      "Achievement unlocked: Temporary competence.",
      "Your to-do list just filed for unemployment."
    ];

    /* ---------- duplicate detection ---------- */
    const STOP=new Set("the,a,an,and,or,for,to,of,in,on,at,by,with,from,as,is,are,be,was,were,do,does,did,this,that,these,those,my,our,your,their".split(","));
    const tokens=(s)=>(s||"").toLowerCase().replace(/[^a-z0-9\s-]/g," ").split(/\s+/).filter(w=>w && !STOP.has(w));
    function jaccard(a,b){const A=new Set(tokens(a)),B=new Set(tokens(b)); if(A.size===0||B.size===0) return 0; let i=0; for(const w of A) if(B.has(w)) i++; return i/(A.size+B.size-i);}
    const leadingNum=(s)=>((s||"").match(/^\s*(\d{3,})/)||[])[1]||null;
    const isLikelyDuplicate=(a,b)=>{const na=leadingNum(a),nb=leadingNum(b); return (na&&nb&&na===nb)|| jaccard(a,b)>=0.58;};

    /* ---------- App ---------- */
    function App(){
      useEffect(()=>{ migrateIfEmpty(); }, []);

      const holi=useMemo(()=>abHolidaysMap(),[]);
      const today=startOfDay(new Date());

      const [settings,setSettings]=useState(()=>load(LS_SETTINGS,{
        workStartMins: minutes(9,0),
        workEndMins: minutes(17,0),
        slotSize: 30,
        weekStartsOn: 1,
        dailyCapacityMins: 7*60,
        bufferMins: 5,
        preferMornings: true,
        tone: "mild",
        theme: "auto"
      }));
      const [tasks,setTasks]=useState(()=>load(LS_TASKS,[]));
      const [blocks,setBlocks]=useState(()=>load(LS_BLOCKS,[]));
      const [anchorDate,setAnchorDate]=useState(()=>startOfWeek(today, settings.weekStartsOn));
      const [search,setSearch]=useState("");
      const [toast,setToast]=useState(null);
      const [editor,setEditor]=useState(null);
      const [dragId,setDragId]=useState(null);

      useEffect(()=>save(LS_SETTINGS,settings),[settings]);
      useEffect(()=>save(LS_TASKS,tasks),[tasks]);
      useEffect(()=>save(LS_BLOCKS,blocks),[blocks]);

      // theme
      useEffect(()=>{
        const prefersDark=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dark=settings.theme==="dark" || (settings.theme==="auto" && prefersDark);
        document.documentElement.classList.toggle("dark",dark);
      },[settings.theme]);

      // move missed forward, jump to this week
      useEffect(()=>{
        const todayKey=toKey(today);
        setTasks(prev=>{
          const next=prev.map(t=>({...t}));
          for(const t of next){
            if(t.done) continue;
            if(t.scheduledStart){
              const s=new Date(t.scheduledStart);
              if(toKey(s)<todayKey){
                t._original=t._original||{date:toKey(s), time:humanTime(s)};
                t.scheduledStart=addMinutes(today, settings.workStartMins).toISOString();
                t._missed=true;
              }
            }else if(t.dayLock && t.dayLock<todayKey){
              t._original=t._original||{date:t.dayLock, time:null};
              t.dayLock=todayKey; t._missed=true;
            }
          }
          return next;
        });
        setAnchorDate(startOfWeek(today, settings.weekStartsOn));
      // eslint-disable-next-line
      },[]);

      /* ---------- search ---------- */
      const searchToks=useMemo(()=>search.trim().toLowerCase().split(/\s+/).filter(Boolean),[search]);
      const matches=(t)=>{
        if(searchToks.length===0) return true;
        const hay=[
          t.title||"", t.notes||"", t.calendar||"",
          t.priority===1?"high":t.priority===3?"low":"medium",
          t.done?"done":"", t._missed?"missed":"",
          t.scheduledStart?toKey(new Date(t.scheduledStart)):(t.dayLock||"")
        ].join(" ").toLowerCase();
        return searchToks.every(tok=>hay.includes(tok));
      };

      /* ---------- busy blocks ---------- */
      function busyOn(day){
        const key=toKey(day); const arr=[];
        for(const t of tasks){
          if(!t.scheduledStart) continue;
          const s=new Date(t.scheduledStart);
          if(toKey(s)===key) arr.push({start:s, duration:t.duration, t});
        }
        arr.sort((a,b)=>{
          const ad=a.t.done, bd=b.t.done;
          if(ad!==bd) return ad?1:-1;
          return a.start-b.start;
        });
        return arr;
      }

      /* ---------- auto-schedule ---------- */
      function autoSchedule(){
        setTasks(prev=>{
          const next=prev.map(t=>({...t,_moved:false}));
          const workStart=settings.workStartMins, workEnd=settings.workEndMins, slot=settings.slotSize, buffer=settings.bufferMins;
          function canPlace(start,dur,dayBusy){
            for(const b of dayBusy){
              const A1=start.getTime()-buffer*60000, A2=A1+(dur+buffer*2)*60000;
              const B1=b.start.getTime()-buffer*60000, B2=B1+(b.duration+buffer*2)*60000;
              if(A1<B2 && B1<A2) return false;
            } return true;
          }
          const items=next.filter(t=>!t.done).sort((a,b)=>a.priority-b.priority || (a.dueDate>b.dueDate?1:-1));
          for(const t of items){
            if(t.scheduledStart && !t.flexible && !t._missed) continue;
            const rangeStart=t.dayLock? parseKey(t.dayLock) : (t.windowStart?parseKey(t.windowStart): startOfDay(new Date()));
            const rangeEnd=t.dayLock? parseKey(t.dayLock) : (t.windowEnd?parseKey(t.windowEnd): parseKey(t.dueDate));
            let placed=!!t.scheduledStart;
            const days=Math.max(1, Math.ceil((endOfDay(rangeEnd)-startOfDay(rangeStart))/86400000)+1);
            for(let d=0; d<days && !placed; d++){
              const day=addMinutes(rangeStart,d*1440);
              const busy=busyOn(day);
              const used=busy.reduce((s,b)=>s+b.duration,0);
              if(used + t.duration > settings.dailyCapacityMins) continue;

              const order=[]; for(let m=workStart; m+t.duration<=workEnd; m+=slot) order.push(m);
              if(!settings.preferMornings) order.reverse();
              for(const m of order){
                const s=addMinutes(day,m);
                if(canPlace(s,t.duration,busy)){
                  t.scheduledStart=s.toISOString();
                  t._moved=true; placed=true; break;
                }
              }
            }
          }
          return next;
        });
      }
      const clearSchedules=()=>setTasks(prev=>prev.map(t=>({...t,scheduledStart:null,_moved:false})));

      /* ---------- gold star + chime ---------- */
      function chime(){
        try{
          const ctx=new (window.AudioContext||window.webkitAudioContext)();
          const o=ctx.createOscillator(), g=ctx.createGain();
          o.type="sine"; o.frequency.value=880; g.gain.value=0.001; o.connect(g); g.connect(ctx.destination); o.start();
          const t=ctx.currentTime;
          g.gain.exponentialRampToValueAtTime(0.03,t+0.02);
          o.frequency.exponentialRampToValueAtTime(1320,t+0.15);
          g.gain.exponentialRampToValueAtTime(0.00001,t+0.6);
          o.stop(t+0.65);
        }catch{}
      }
      function confetti(){ for(let i=0;i<40;i++){ const s=document.createElement("span"); s.className="confetti"; s.style.left=Math.random()*100+"%"; s.style.animationDelay=(Math.random()*0.4)+"s"; document.body.appendChild(s); setTimeout(()=>s.remove(),2500);} }
      function toggleDone(id){
        setTasks(prev=>{
          const next=prev.map(t=>t.id===id?({...t,done:!t.done}):t);
          setTimeout(()=>{
            const tk=toKey(startOfDay(new Date()));
            const todays=next.filter(t=>t.scheduledStart && toKey(new Date(t.scheduledStart))===tk);
            const allDone=todays.length>0 && todays.every(t=>t.done);
            if(allDone){
              const pool=settings.tone==="random"? [...SNARK_MILD,...SNARK_CHAOS] : (settings.tone==="chaos"?SNARK_CHAOS:SNARK_MILD);
              setToast(pool[Math.floor(Math.random()*pool.length)]);
              confetti(); chime();
            }
          },50);
          return next;
        });
      }

      /* ---------- export / import ---------- */
      function exportData(){
        const data={ tasks:load(LS_TASKS,[]), blocks:load(LS_BLOCKS,[]), settings:load(LS_SETTINGS,null), exportedAt:new Date().toISOString(), version:"v3.3" };
        const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
        const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="chaos-control-backup.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      function importData(file){
        if(!file) return;
        const reader=new FileReader();
        reader.onload=()=>{
          try{
            const obj=JSON.parse(reader.result);
            if(obj.tasks) save(LS_TASKS,obj.tasks);
            if(obj.blocks) save(LS_BLOCKS,obj.blocks);
            if(obj.settings) save(LS_SETTINGS,obj.settings);
            setTasks(load(LS_TASKS,[])); setBlocks(load(LS_BLOCKS,[])); setSettings(load(LS_SETTINGS,null)||{});
            alert("Import complete ‚úÖ");
          }catch{ alert("Import failed: not a valid backup file."); }
        };
        reader.readAsText(file);
      }

      /* ---------- add task ---------- */
      function addTaskFromForm(data){
        const title=(data.get("title")||"").toString().trim();
        if(!title) return alert("Please enter a task title.");
        const durH=parseInt((data.get("dur_h")||"0"),10)||0;
        const durM=parseInt((data.get("dur_m")||"0"),10)||0;
        const duration=Math.max(5, Math.min(24*60, durH*60+durM || 30));
        const priority=parseInt((data.get("priority")||"2"),10)||2;
        const calendar=(data.get("calendar")||"work").toString();
        const mode=(data.get("mode")||"flex").toString();

        let flexible=true, windowStart=toKey(new Date()), windowEnd=toKey(new Date()), dayLock=null, scheduledStart=null, dueDate=windowEnd;

        if(mode==="flex"){
          const preset=(data.get("flex_preset")||"today").toString();
          const base=startOfDay(new Date());
          if(preset==="today"){ windowStart=toKey(base); windowEnd=toKey(base); }
          else if(preset==="next2"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(base,1440)); }
          else if(preset==="thisweek"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(startOfWeek(base, settings.weekStartsOn),6*1440)); }
          else { const by=(data.get("flex_by")||toKey(base)).toString(); windowStart=toKey(base); windowEnd=by; }
          dueDate=windowEnd;
        }else{
          flexible=false;
          const d=(data.get("fixed_date")||"").toString();
          const t=(data.get("fixed_time")||"").toString();
          dueDate=d || toKey(new Date());
          if(d && t) scheduledStart=new Date(`${d}T${t}:00`).toISOString();
          else if(d) dayLock=d;
        }

        // duplicate warning
        const overlap=(x)=> (dayLock && x.dayLock && x.dayLock===dayLock)
                          || (dueDate && x.dueDate && x.dueDate===dueDate)
                          || (!dayLock && !x.dayLock && windowStart<=x.windowEnd && x.windowStart<=windowEnd);
        const dups=tasks.filter(t=>overlap(t) && isLikelyDuplicate(title,t.title));
        if(dups.length){
          const names=dups.slice(0,3).map(d=>"‚Ä¢ "+d.title).join("\n");
          const ok=confirm(`Heads up ‚Äî this looks similar:\n${names}\n\nAdd anyway?`);
          if(!ok) return;
        }

        const newTask={
          id:uid(), title, duration, priority, calendar,
          flexible, windowStart, windowEnd, dayLock, scheduledStart, dueDate,
          done:false, _moved:false, _missed:false
        };
        setTasks(prev=>[newTask,...prev]);
      }

      /* ---------- rescheduling ---------- */
      function rescheduleTask(id, days){
        setTasks(prev=>prev.map(t=>{
          if(t.id!==id) return t;
          let base = t.scheduledStart? new Date(t.scheduledStart) : (t.dayLock? parseKey(t.dayLock) : startOfDay(new Date()));
          base.setDate(base.getDate()+days);
          t._original=t._original || {date:t.dayLock || (t.scheduledStart?toKey(new Date(t.scheduledStart)):null), time:t.scheduledStart?humanTime(new Date(t.scheduledStart)):null};
          if(t.scheduledStart){ t.scheduledStart=base.toISOString(); } else { t.dayLock=toKey(base); }
          t._missed=true;
          return {...t};
        }));
      }

      /* ---------- header ---------- */
      function Header(){
        return (
          <header className="hdr">
            <div className="title">
              <span className="word-chaos"><span className="bomb-bg" aria-hidden="true"></span>Chaos</span> Control ‚Äî Smart Scheduler
            </div>
            <div className="hdr-tools">
              <input className="search" placeholder="üîç Search tasks‚Ä¶ (high, missed, Oct 23)"
                     value={search} onChange={(e)=>setSearch(e.target.value)}/>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate,-7*1440))} title="Prev week">¬´ Wk</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate,-1*1440))} title="Prev day">‚Äπ Day</button>
              <button className="btn primary" onClick={()=>setAnchorDate(startOfWeek(startOfDay(new Date()), settings.weekStartsOn))} title="Go to today">Today</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate,1*1440))} title="Next day">Day ‚Ä∫</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate,7*1440))} title="Next week">Wk ¬ª</button>
            </div>
          </header>
        );
      }

      /* ---------- add bar ---------- */
      function AddBar(){
        const ref=useRef();
        return (
          <form className="addbar" onSubmit={(e)=>{e.preventDefault(); const fd=new FormData(e.currentTarget); addTaskFromForm(fd); e.currentTarget.reset(); ref.current?.blur();}}>
            <input ref={ref} className="addbar-title" name="title" placeholder="‚ûï Add a new task‚Ä¶"/>
            <div className="addbar-row">
              <label>Duration</label>
              <input type="number" inputMode="numeric" className="w80" name="dur_h" min="0" defaultValue="1"/> hr
              <input type="number" inputMode="numeric" className="w80" name="dur_m" min="0" max="55" step="5" defaultValue="0"/> min
              <label>Priority</label>
              <select name="priority" defaultValue="2">
                <option value="1">High</option><option value="2">Medium</option><option value="3">Low</option>
              </select>
              <label>When</label>
              <span className="seg">
                <label><input type="radio" name="mode" value="flex" defaultChecked/> Flexible</label>
                <label><input type="radio" name="mode" value="fixed"/> Fixed</label>
              </span>
              <span className="seg">
                <label><input type="radio" name="flex_preset" value="today" defaultChecked/> Today</label>
                <label><input type="radio" name="flex_preset" value="next2"/> Next 2d</label>
                <label><input type="radio" name="flex_preset" value="thisweek"/> This week</label>
                <label><input type="radio" name="flex_preset" value="by"/> By date</label>
                <input type="date" name="flex_by" className="w140"/>
              </span>
              <span className="seg">
                <label>Fixed date</label>
                <input type="date" name="fixed_date" className="w140"/>
                <label>time</label>
                <input type="time" name="fixed_time" className="w120"/>
              </span>
              <label>Calendar</label>
              <select name="calendar" defaultValue="work">
                <option value="work">Work</option><option value="team">Team</option><option value="personal">Home</option>
              </select>
              <button className="btn primary" type="submit">Add</button>
              <button className="btn" type="button" onClick={autoSchedule}>Auto-Schedule</button>
              <button className="btn" type="button" onClick={clearSchedules}>Clear</button>
            </div>
          </form>
        );
      }

      /* ---------- modal editor ---------- */
      function openEditor(t){
        const dur_h=Math.floor((t.duration||60)/60), dur_m=(t.duration||60)%60;
        setEditor({
          id:t.id, title:t.title||"",
          dur_h, dur_m,
          priority:String(t.priority||2),
          calendar:t.calendar||"work",
          mode: t.flexible? "flex":"fixed",
          flexPreset:"today",
          flex_by: t.windowEnd || toKey(new Date()),
          fixed_date: t.dayLock || (t.scheduledStart? toKey(new Date(t.scheduledStart)):""),
          fixed_time: t.scheduledStart? `${pad(new Date(t.scheduledStart).getHours())}:${pad(new Date(t.scheduledStart).getMinutes())}` : "",
          done: !!t.done
        });
      }
      function saveEditor(){
        setTasks(prev=>prev.map(t=>{
          if(!editor || t.id!==editor.id) return t;
          const duration=Math.max(5, Math.min(24*60, (parseInt(editor.dur_h||0)*60 + parseInt(editor.dur_m||0))));
          let flexible=true, windowStart=toKey(new Date()), windowEnd=toKey(new Date()), dayLock=null, scheduledStart=null, dueDate=windowEnd;

          if(editor.mode==="flex"){
            const base=startOfDay(new Date());
            const p=editor.flexPreset||"today";
            if(p==="today"){ windowStart=toKey(base); windowEnd=toKey(base); }
            else if(p==="next2"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(base,1440)); }
            else if(p==="thisweek"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(startOfWeek(base, settings.weekStartsOn),6*1440)); }
            else { windowStart=toKey(base); windowEnd=editor.flex_by||toKey(base); }
            dueDate=windowEnd;
          }else{
            flexible=false;
            const d=editor.fixed_date||"", tm=editor.fixed_time||"";
            dueDate=d || t.dueDate;
            if(d && tm) scheduledStart=new Date(`${d}T${tm}:00`).toISOString();
            else if(d) dayLock=d;
          }

          return {...t,
            title: editor.title.trim()||t.title,
            duration, priority:parseInt(editor.priority||"2",10)||2,
            calendar:editor.calendar||t.calendar,
            flexible, windowStart, windowEnd, dayLock, scheduledStart, dueDate,
            done: !!editor.done
          };
        }));
        setEditor(null);
      }
      function delTask(id){ setTasks(prev=>prev.filter(t=>t.id!==id)); setEditor(null); }
      function Modal(){ if(!editor) return null; return (
        <div className="modal-backdrop" onClick={()=>setEditor(null)}>
          <div className="modal" onClick={(e)=>e.stopPropagation()}>
            <div className="mh"><div>Edit Task</div><button className="btn" onClick={()=>setEditor(null)}>‚úñ</button></div>
            <div className="row"><input type="text" value={editor.title} onChange={(e)=>setEditor({...editor,title:e.target.value})} placeholder="Title" autoFocus/></div>
            <div className="row">
              <div style={{flex:1}}><label>Hours</label><input type="number" inputMode="numeric" value={editor.dur_h} onChange={(e)=>setEditor({...editor,dur_h:e.target.value})}/></div>
              <div style={{flex:1}}><label>Minutes</label><input type="number" inputMode="numeric" step="5" min="0" max="55" value={editor.dur_m} onChange={(e)=>setEditor({...editor,dur_m:e.target.value})}/></div>
            </div>
            <div className="row">
              <div style={{flex:1}}><label>Priority</label>
                <select value={editor.priority} onChange={(e)=>setEditor({...editor,priority:e.target.value})}>
                  <option value="1">High</option><option value="2">Medium</option><option value="3">Low</option>
                </select>
              </div>
              <div style={{flex:1}}><label>Calendar</label>
                <select value={editor.calendar} onChange={(e)=>setEditor({...editor,calendar:e.target.value})}>
                  <option value="work">Work</option><option value="team">Team</option><option value="personal">Home</option>
                </select>
              </div>
            </div>
            <div className="row">
              <div className="seg">
                <label><input type="radio" checked={editor.mode==="flex"} onChange={()=>setEditor({...editor,mode:"flex"})}/> Flexible</label>
                <label><input type="radio" checked={editor.mode==="fixed"} onChange={()=>setEditor({...editor,mode:"fixed"})}/> Fixed</label>
              </div>
            </div>
            {editor.mode==="flex" ? (
              <div className="row">
                <div className="seg">
                  <label><input type="radio" name="fp" checked={editor.flexPreset==="today"} onChange={()=>setEditor({...editor,flexPreset:"today"})}/> Today</label>
                  <label><input type="radio" name="fp" checked={editor.flexPreset==="next2"} onChange={()=>setEditor({...editor,flexPreset:"next2"})}/> Next 2d</label>
                  <label><input type="radio" name="fp" checked={editor.flexPreset==="thisweek"} onChange={()=>setEditor({...editor,flexPreset:"thisweek"})}/> This week</label>
                  <label><input type="radio" name="fp" checked={editor.flexPreset==="by"} onChange={()=>setEditor({...editor,flexPreset:"by"})}/> By date</label>
                  <input type="date" value={editor.flex_by} onChange={(e)=>setEditor({...editor,flex_by:e.target.value})}/>
                </div>
              </div>
            ) : (
              <div className="row">
                <div style={{flex:1}}><label>Fixed date</label><input type="date" value={editor.fixed_date||""} onChange={(e)=>setEditor({...editor,fixed_date:e.target.value})}/></div>
                <div style={{flex:1}}><label>time</label><input type="time" value={editor.fixed_time||""} onChange={(e)=>setEditor({...editor,fixed_time:e.target.value})}/></div>
              </div>
            )}
            <div className="row"><label className="chk"><input type="checkbox" checked={!!editor.done} onChange={(e)=>setEditor({...editor,done:e.target.checked})}/> Mark complete</label></div>
            <div className="actions">
              <button className="btn danger" onClick={()=>delTask(editor.id)}>Delete</button>
              <button className="btn" onClick={()=>setEditor(null)}>Cancel</button>
              <button className="btn primary" onClick={saveEditor}>Save</button>
            </div>
          </div>
        </div>
      );}

      /* ---------- task card ---------- */
      function TaskCard({t}){
        return (
          <div className={"taskcard"+(t.priority===1?" high":"")+(t._missed?" missed":"")}
               draggable
               onDragStart={(e)=>{setDragId(t.id); e.dataTransfer.setData("text/plain", t.id);}}
               onDragEnd={()=>setDragId(null)}
               onClick={()=>openEditor(t)}>
            <div className="row">
              <div className="ttl">{t.title}</div>
              <label className="chk"><input type="checkbox" checked={!!t.done} onChange={(e)=>{e.stopPropagation(); toggleDone(t.id);}}/> Done</label>
            </div>
            <div className="meta">
              <span>{t.duration} min</span>
              {t.scheduledStart && <span>{toKey(new Date(t.scheduledStart))} {humanTime(new Date(t.scheduledStart))}</span>}
              {!t.scheduledStart && t.dayLock && <span>pinned {t.dayLock}</span>}
              {!t.scheduledStart && !t.dayLock && <span>flex {t.windowStart} ‚Üí {t.windowEnd}</span>}
              {t._missed && <span className="badge">Rescheduled</span>}
            </div>
            {t._original && <div className="orig">Originally {t._original.date}{t._original.time?(" ‚Ä¢ "+t._original.time):""}</div>}
          </div>
        );
      }

      /* ---------- day column ---------- */
      function DayColumn({day}){
        const key=toKey(day);
        const busy=busyOn(day);
        const used=busy.reduce((s,b)=>s+b.duration,0);
        const cap=settings.dailyCapacityMins;
        const pct=Math.min(100, Math.round((used/cap)*100));
        const holiday=holi.get(key);
        const hasTasks=busy.length>0;
        const allDone=hasTasks && busy.every(b=>b.t.done);

        const ref=useRef(null);
        const [dropY,setDropY]=useState(null);
        const [showSummary,setShowSummary]=useState(false);

        function nearestTime(clientY){
          const r=ref.current?.getBoundingClientRect(); if(!r) return null;
          const y=Math.max(0, Math.min(clientY - r.top, r.height));
          const range=settings.workEndMins-settings.workStartMins;
          const minsPerPx=range / r.height;
          let m=Math.round((y*minsPerPx)/settings.slotSize)*settings.slotSize;
          m=Math.max(0, Math.min(m, range - settings.slotSize));
          return addMinutes(startOfDay(day), settings.workStartMins + m);
        }
        function onDragOver(e){ if(dragId){ e.preventDefault(); setDropY(e.clientY); } }
        function onDrop(e){
          if(!dragId) return;
          e.preventDefault();
          const s=nearestTime(e.clientY);
          if(!s) return;
          setTasks(prev=>prev.map(t=>t.id===dragId?({...t, scheduledStart:s.toISOString(), dayLock:null, flexible:false, _missed:false}):t));
          setDragId(null); setDropY(null);
        }

        return (
          <div className={"daycol"+(key===toKey(startOfDay(new Date()))?" today":"")+(holiday?" holiday":"")}>
            {allDone && <div className="day-ribbon"></div>}
            <div className="dayhdr" onClick={()=>setShowSummary(v=>!v)} title="Click for summary">
              <div className="dname">{day.toLocaleDateString(undefined,{weekday:"short"})}</div>
              <div className="dnum">{day.getDate()}</div>
              <div className="cap"><span style={{width:pct+"%"}}/></div>
              {holiday && <div className="holiday-name">{holiday}</div>}
            </div>

            {showSummary && (
              <div className={"day-summary"+(pct>=100?" full":"")}>
                <div><strong>Scheduled:</strong> {used} min</div>
                <div><strong>Capacity used:</strong> {pct}%</div>
                <div><strong>Free:</strong> {Math.max(0,cap-used)} min</div>
              </div>
            )}

            <div className={"busy"+(dragId?" drag-target":"")} ref={ref} onDragOver={onDragOver} onDrop={onDrop} onDragLeave={()=>setDropY(null)}>
              {dropY && <div className="drop-indicator" style={{top:(dropY - (ref.current?.getBoundingClientRect()?.top||0))+'px'}}/>}
              {busy.map((b,i)=>(
                <div key={i}
                     className={"busyitem"+(b.t.priority===1?" high":"")+(b.t._missed?" missed":"")+(b.t.done?" done":"")}
                     draggable
                     onDragStart={(e)=>{setDragId(b.t.id); e.dataTransfer.setData("text/plain", b.t.id);}}
                     onDragEnd={()=>setDragId(null)}
                     onClick={()=>openEditor(b.t)}>
                  <div className="row">
                    <div className="time">{humanTime(b.start)}‚Äì{humanTime(endTime(b.start,b.duration))}</div>
                    <div className="row">
                      <label className="chk"><input type="checkbox" checked={!!b.t.done} onChange={(e)=>{e.stopPropagation(); toggleDone(b.t.id);}}/> Done</label>
                      <button className="btn xs" onClick={(e)=>{e.stopPropagation(); openEditor(b.t);}}>‚úèÔ∏è</button>
                    </div>
                  </div>
                  <div className="ttl">{b.t.title}</div>
                  {b.t._original && <div className="orig">Originally {b.t._original.date}{b.t._original.time?(" ‚Ä¢ "+b.t._original.time):""}</div>}
                  <div className="row right">
                    <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id,1);}}>+1d</button>
                    <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id,2);}}>+2d</button>
                    <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id,7);}}>+1w</button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      }

      /* ---------- layout ---------- */
      const weekDays=useMemo(()=>Array.from({length:7},(_,i)=>addMinutes(anchorDate,i*1440)),[anchorDate]);
      const unscheduled=tasks.filter(t=>!t.scheduledStart && !t.done && matches(t));
      return (
        <div className="wrap">
          <Header/>
          <AddBar/>

          <div className="layout">
            <aside className="left">
              <div className="panel">
                <div className="panel-h">üóíÔ∏è Unscheduled Tasks</div>
                {unscheduled.length===0 ? <div className="empty">Nothing here ‚Äî everything else is on the calendar.</div>
                  : unscheduled.map(t=><TaskCard key={t.id} t={t}/>)}
              </div>

              <div className="panel">
                <div className="panel-h">Settings</div>
                <div className="row">
                  <label>Workday</label>
                  <input type="time"
                    value={`${String(Math.floor(settings.workStartMins/60)).padStart(2,"0")}:${String(settings.workStartMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{const [h,m]=e.target.value.split(":").map(Number); setSettings(s=>({...s,workStartMins:minutes(h,m)}));}}/>
                  <span>‚Äì</span>
                  <input type="time"
                    value={`${String(Math.floor(settings.workEndMins/60)).padStart(2,"0")}:${String(settings.workEndMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{const [h,m]=e.target.value.split(":").map(Number); setSettings(s=>({...s,workEndMins:minutes(h,m)}));}}/>
                </div>
                <div className="row">
                  <label>Tone</label>
                  <select value={settings.tone} onChange={(e)=>setSettings(s=>({...s,tone:e.target.value}))}>
                    <option value="mild">Mild Spice</option>
                    <option value="chaos">Full Chaos</option>
                    <option value="random">Surprise me</option>
                  </select>
                </div>
                <div className="row">
                  <label>Theme</label>
                  <select value={settings.theme} onChange={(e)=>setSettings(s=>({...s,theme:e.target.value}))}>
                    <option value="auto">Auto</option><option value="light">Light</option><option value="dark">Dark</option>
                  </select>
                </div>
                <div className="row">
                  <button className="btn" onClick={autoSchedule}>Auto-Schedule All</button>
                  <button className="btn" onClick={exportData}>Export JSON</button>
                  <label className="btn" style={{position:"relative",overflow:"hidden"}}>
                    Import JSON
                    <input type="file" accept="application/json"
                      onChange={(e)=>importData(e.target.files[0])}
                      style={{position:"absolute",inset:0,opacity:0,cursor:"pointer"}}/>
                  </label>
                </div>
              </div>
            </aside>

            <main className="main">
              <div className="week">
                {weekDays.map(d=><DayColumn key={d.toISOString()} day={d}/>)}
              </div>
            </main>
          </div>

          {toast && <div className="toast" onClick={()=>setToast(null)}><div className="star">‚≠ê</div><div className="msg">{toast}</div></div>}
          <footer className="ftr">Chaos Control v3.3 ‚Ä¢ for <strong>dysfunctional adults managing total chaos</strong>.</footer>

          <Modal/>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(<App/>);
  </script>
</body>
</html>
