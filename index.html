<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chaos Control ‚Äî Smart Scheduler v3</title>
  <link rel="stylesheet" href="styles.css"/>
  <!-- React & Babel from CDN for zero-build deploy -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <script type="text/babel">
    const {useState, useEffect, useMemo, useRef} = React;

    const pad = (n) => String(n).padStart(2, "0");
    const minutes = (h, m=0) => h*60 + m;
    const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
    const addMinutes = (date, mins) => { const d=new Date(date); d.setMinutes(d.getMinutes()+mins); return d; };
    const toKey = (d) => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    const parseKey = (s) => { const [y,m,d]=s.split("-").map(Number); return new Date(y, m-1, d); };
    const startOfDay = (d) => { const x=new Date(d); x.setHours(0,0,0,0); return x; };
    const endOfDay = (d) => { const x=new Date(d); x.setHours(23,59,59,999); return x; };
    const startOfWeek = (d, weekStartsOn=1) => { const x=new Date(d); const day=(x.getDay()+7-weekStartsOn)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x; };
    const humanTime = (d) => `${pad(d.getHours())}:${pad(d.getMinutes())}`;
    const endTime = (start, dur) => addMinutes(start, dur);
    const sameMinute = (a,b) => a && b && a.getTime()===b.getTime();
    const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));

    const LS_TASKS="cc_tasks_v3_final";
    const LS_BLOCKS="cc_blocks_v3_final";
    const LS_SETTINGS="cc_settings_v3_final";
    const load = (k,fb) => { try { const raw=localStorage.getItem(k); return raw?JSON.parse(raw):fb } catch { return fb } };
    const save = (k,v) => { try { localStorage.setItem(k, JSON.stringify(v)) } catch {} };

    function easterDate(year){
      const a = year % 19;
      const b = Math.floor(year / 100);
      const c = year % 100;
      const d = Math.floor(b / 4);
      const e = b % 4;
      const f = Math.floor((b + 8) / 25);
      const g = Math.floor((b - f + 1) / 3);
      const h = (19*a + b - d - g + 15) % 30;
      const i = Math.floor(c / 4);
      const k = c % 4;
      const l = (32 + 2*e + 2*i - h - k) % 7;
      const m = Math.floor((a + 11*h + 22*l) / 451);
      const month = Math.floor((h + l - 7*m + 114) / 31);
      const day = ((h + l - 7*m + 114) % 31) + 1;
      return new Date(year, month-1, day);
    }
    function nthDowOfMonth(year, monthIndex, dow, n){
      const first = new Date(year, monthIndex, 1);
      const firstDow = first.getDay();
      const offset = (dow - firstDow + 7) % 7;
      const date = 1 + offset + (n-1)*7;
      return new Date(year, monthIndex, date);
    }
    function lastDowBefore(year, monthIndex, dayLimit, dow){
      const d = new Date(year, monthIndex, dayLimit);
      while (d.getDay() !== dow) d.setDate(d.getDate()-1);
      return d;
    }
    function albertaHolidaysForYear(year){
      const list = [];
      const push = (d, name) => list.push({date: toKey(d), name});
      push(new Date(year,0,1), "New Year's Day");
      push(nthDowOfMonth(year,1,1,3), "Family Day");
      const easter = easterDate(year);
      const goodFriday = new Date(easter); goodFriday.setDate(easter.getDate()-2);
      push(goodFriday, "Good Friday");
      push(lastDowBefore(year,4,24,1), "Victoria Day");
      push(new Date(year,6,1), "Canada Day");
      push(nthDowOfMonth(year,8,1,1), "Labour Day");
      push(new Date(year,8,30), "National Day for Truth and Reconciliation");
      push(nthDowOfMonth(year,9,1,2), "Thanksgiving");
      push(new Date(year,10,11), "Remembrance Day");
      push(new Date(year,11,25), "Christmas Day");
      push(new Date(year,11,26), "Boxing Day");
      return list;
    }
    function holidayMap(){
      const y = new Date().getFullYear();
      const all = [...albertaHolidaysForYear(y), ...albertaHolidaysForYear(y+1)];
      const m = new Map();
      all.forEach(h => m.set(h.date, h.name));
      return m;
    }

    const SNARK_MILD = [
      "Well look at you, functioning adult of the year.",
      "Everything done? I‚Äôm as shocked as you are.",
      "Achievement unlocked: Did the bare minimum, but in style.",
      "The productivity gods are appeased‚Ä¶ for now.",
      "Chaos temporarily under control. Carry on."
    ];
    const SNARK_CHAOS = [
      "Everything done? Who kidnapped you and replaced you with someone responsible?",
      "You finished *everything*? Screenshot it before reality reloads.",
      "Task list annihilated. Chaos 0 ‚Äì You 1.",
      "Achievement unlocked: Temporary competence.",
      "Your to‚Äëdo list just filed for unemployment."
    ];

    function App(){
      const holi = React.useMemo(()=>holidayMap(), []);
      const today = startOfDay(new Date());
      const [settings, setSettings] = useState(()=>load(LS_SETTINGS, {
        workStartMins: 540,
        workEndMins: 1020,
        slotSize: 30,
        weekStartsOn: 1,
        dailyCapacityMins: 420,
        bufferMins: 5,
        preferMornings: true,
        tone: "mild",
        theme: "auto"
      }));
      const [tasks, setTasks] = useState(()=>load(LS_TASKS, []));
      const [blocks, setBlocks] = useState(()=>load(LS_BLOCKS, []));
      const [anchorDate, setAnchorDate] = useState(()=> startOfWeek(today, settings.weekStartsOn));
      const [selectedTaskId, setSelectedTaskId] = useState(null);
      const [search, setSearch] = useState("");
      const [showSnark, setShowSnark] = useState(null);
      const [showDatePicker, setShowDatePicker] = useState(false);

      useEffect(()=>save(LS_SETTINGS, settings), [settings]);
      useEffect(()=>save(LS_TASKS, tasks), [tasks]);
      useEffect(()=>save(LS_BLOCKS, blocks), [blocks]);

      useEffect(()=>{
        const preferDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dark = settings.theme === "dark" || (settings.theme==="auto" && preferDark);
        document.documentElement.classList.toggle("dark", dark);
      }, [settings.theme]);

      useEffect(()=>{
        setTasks(prev => {
          const next = prev.map(t=>({...t}));
          const nowKey = toKey(today);
          for(const t of next){
            if(t.done) continue;
            if(t.scheduledStart){
              const s = new Date(t.scheduledStart);
              if(toKey(s) < nowKey){
                const ns = addMinutes(today, settings.workStartMins);
                t._original = t._original || { date: toKey(s), time: humanTime(s) };
                t.scheduledStart = ns.toISOString();
                t._missed = true;
              }
              continue;
            }
            if(t.dayLock && t.dayLock < nowKey){
              const ns = addMinutes(today, settings.workStartMins);
              t._original = t._original || { date: t.dayLock, time: null };
              t.dayLock = toKey(today);
              t.scheduledStart = ns.toISOString();
              t._missed = true;
            }
          }
          return next;
        });
        setAnchorDate(startOfWeek(today, settings.weekStartsOn));
      }, []);

      const calmap = React.useMemo(()=> ({
        work:   {id:"work", name:"Work",    color:"#2563eb"},
        team:   {id:"team", name:"Team",    color:"#16a34a"},
        personal:{id:"personal", name:"Home", color:"#9333ea"},
      }), []);

      const weekDays = React.useMemo(()=> Array.from({length:7}, (_,i)=> addMinutes(anchorDate, i*1440)), [anchorDate]);
      const todayKey = toKey(today);

      const searchTokens = React.useMemo(()=> search.trim().toLowerCase().split(/\s+/).filter(Boolean), [search]);
      function matchesSearch(t){
        if(searchTokens.length===0) return true;
        const hay = [
          t.title || "",
          (t.notes||""),
          (t.calendar||""),
          t.priority===1?"high":t.priority===3?"low":"medium",
          t.done?"done":"",
          t._missed?"missed":"",
          t.scheduledStart?toKey(new Date(t.scheduledStart)):(t.dayLock||""),
        ].join(" ").toLowerCase();
        return searchTokens.every(tok => hay.includes(tok));
      }

      function findSimilarTasks(candidate){
        const norm = (s) => (s||"").toLowerCase();
        const nums = (s) => (s||"").match(/\d+/g)||[];
        const cTitle = norm(candidate.title);
        const cNums = nums(cTitle).join("|");
        const cDay = candidate.fixedDate || candidate.dayLock || candidate.windowEnd || candidate.dueDate;
        return tasks.filter(t=>{
          if(!t.id || t.id===candidate.id) return false;
          const tTitle = norm(t.title);
          const shareNum = cNums && tTitle.match(new RegExp(cNums.replace(/\|/g,"|")));
          const shareWord = cTitle && tTitle.split(/\W+/).some(w => w.length>3 && tTitle.includes(w));
          const sameDay = cDay && (t.dayLock===cDay || (t.scheduledStart && toKey(new Date(t.scheduledStart))===cDay));
          return (shareNum || shareWord) && sameDay;
        });
      }

      function busyBlocksOnDay(dayDate){
        const dayKey = toKey(dayDate);
        const busy = [];
        for(const b of blocks){
          const s = new Date(b.startISO);
          if(toKey(s)===dayKey) busy.push({start:s, duration:b.duration, title:b.title, type:"block", calendar:b.calendar, blockId:b.id});
        }
        for(const t of tasks){
          if(!t.scheduledStart || t.done) continue;
          const s = new Date(t.scheduledStart);
          if(toKey(s)===dayKey) busy.push({start:s, duration:t.duration, title:t.title, type:"task", calendar:t.calendar, taskId:t.id, t});
        }
        busy.sort((a,b)=>a.start-b.start);
        return busy;
      }

      function autoSchedule(selectedOnly=false){
        setTasks(prev=>{
          const next = prev.map(t=>({...t, _moved:false}));
          const workStart = settings.workStartMins, workEnd=settings.workEndMins;
          const slot = settings.slotSize, buffer=settings.bufferMins;

          function canPlace(start, dur, dayBusy){
            for(const b of dayBusy){
              const A1 = start.getTime() - buffer*60000;
              const A2 = A1 + (dur + buffer*2)*60000;
              const B1 = b.start.getTime() - buffer*60000;
              const B2 = B1 + (b.duration + buffer*2)*60000;
              if(A1 < B2 && B1 < A2) return false;
            }
            return true;
          }

          const candidates = next
            .filter(t=>!t.done)
            .filter(t=> selectedOnly ? t.id===selectedTaskId : true)
            .sort((a,b)=> a.priority-b.priority || (a.dueDate>b.dueDate?1:-1));

          for(const t of candidates){
            const rangeStart = t.dayLock ? parseKey(t.dayLock) : (t.windowStart? parseKey(t.windowStart): startOfDay(new Date()));
            const rangeEnd = t.dayLock ? parseKey(t.dayLock) : (t.windowEnd? parseKey(t.windowEnd): parseKey(t.dueDate));
            let placed = !!t.scheduledStart;
            if(t.scheduledStart && !t.flexible && !t._missed) continue;

            const days = Math.max(1, Math.ceil((endOfDay(rangeEnd)-startOfDay(rangeStart))/86400000)+1);
            for(let d=0; d<days && !placed; d++){
              const day = addMinutes(rangeStart, d*1440);
              const dayKey = toKey(day);
              if (holidayMap().has(dayKey)) continue;
              const busy = busyBlocksOnDay(day);
              const used = busy.reduce((s,b)=>s+b.duration,0);
              if(used + t.duration > settings.dailyCapacityMins) continue;

              const order = [];
              for(let m=workStart; m + t.duration <= workEnd; m += slot) order.push(m);
              if(!settings.preferMornings) order.reverse();

              for(const m of order){
                const start = addMinutes(day, m);
                if(canPlace(start, t.duration, busy)){
                  t.scheduledStart = start.toISOString();
                  t._moved = true;
                  placed = true;
                  break;
                }
              }
            }
          }
          return next;
        });
      }

      function clearSchedules(){ setTasks(prev=>prev.map(t=>({...t, scheduledStart:null, _moved:false}))); }

      function toggleDone(id){
        setTasks(prev=>{
          const next = prev.map(t=> t.id===id ? ({...t, done:!t.done}) : t);
          setTimeout(()=>{
            const anyToday = next.some(t=> t.scheduledStart && toKey(new Date(t.scheduledStart)) === toKey(startOfDay(new Date())) );
            const allDoneToday = anyToday && next.filter(t=> t.scheduledStart && toKey(new Date(t.scheduledStart)) === toKey(startOfDay(new Date())) ).every(t=>t.done);
            if(allDoneToday){
              const pool = settings.tone==="random" ? [...SNARK_MILD, ...SNARK_CHAOS] :
                           settings.tone==="chaos" ? SNARK_CHAOS : SNARK_MILD;
              const msg = pool[Math.floor(Math.random()*pool.length)];
              setShowSnark({msg, when: Date.now()});
              confettiBurst();
            }
          }, 50);
          return next;
        });
      }

      function confettiBurst(){
        const root = document.body;
        for(let i=0;i<40;i++){
          const s = document.createElement('span');
          s.className = 'confetti';
          s.style.left = Math.random()*100 + '%';
          s.style.animationDelay = (Math.random()*0.4)+'s';
          root.appendChild(s);
          setTimeout(()=>root.removeChild(s), 2500);
        }
      }

      function addTaskFromForm(data){
        const title = (data.get("title")||"").toString().trim();
        if(!title) return alert("Please enter a task title.");
        const durH = parseInt((data.get("dur_h")||"0"),10)||0;
        const durM = parseInt((data.get("dur_m")||"0"),10)||0;
        const duration = Math.max(5, Math.min(24*60, (durH*60 + durM || 30)));
        const priority = parseInt((data.get("priority")||"2"),10)||2;
        const calendar = (data.get("calendar")||"work").toString();
        const mode = (data.get("mode")||"flex").toString();

        let flexible=true, windowStart=toKey(new Date()), windowEnd=toKey(new Date()), dayLock=null, scheduledStart=null, dueDate=windowEnd;
        if(mode==="flex"){
          const preset=(data.get("flex_preset")||"today").toString();
          const base = startOfDay(new Date());
          if(preset==="today"){
            windowStart = toKey(base); windowEnd = toKey(base);
          }else if(preset==="next2"){
            windowStart = toKey(base); windowEnd = toKey(addMinutes(base, 1440));
          }else if(preset==="thisweek"){
            windowStart = toKey(base);
            const end = addMinutes(startOfWeek(base, settings.weekStartsOn), 6*1440);
            windowEnd = toKey(end);
          }else{
            const by=(data.get("flex_by")||toKey(base)).toString();
            windowStart = toKey(base); windowEnd = by;
          }
          dueDate = windowEnd;
        } else {
          flexible=false;
          const d = (data.get("fixed_date")||"").toString();
          if(!d) return alert("Pick a date for fixed or pinned task.");
          const t = (data.get("fixed_time")||"").toString();
          dueDate = d;
          if(t){
            scheduledStart = new Date(`${d}T${t}:00`).toISOString();
          } else {
            dayLock = d;
          }
        }

        const newTask = {
          id: uid(), title, duration, priority, calendar,
          flexible, windowStart, windowEnd, dayLock, scheduledStart, dueDate,
          done:false, _moved:false, _missed:false
        };

        const sim = findSimilarTasks({title, dayLock: dayLock || (scheduledStart?toKey(new Date(scheduledStart)):dueDate), id:newTask.id});
        if(sim.length){
          if(!confirm(`Possible duplicate on same day:
- ${sim[0].title}
Add anyway?`)){
            return;
          }
        }

        setTasks(prev=>[newTask, ...prev]);
      }

      function rescheduleTask(id, days){
        setTasks(prev=>prev.map(t=>{
          if(t.id!==id) return t;
          let s = t.scheduledStart ? new Date(t.scheduledStart) : (t.dayLock? parseKey(t.dayLock) : startOfDay(new Date()));
          s.setDate(s.getDate()+days);
          t._original = t._original || {date: t.dayLock || (t.scheduledStart?toKey(new Date(t.scheduledStart)):null), time: t.scheduledStart?humanTime(new Date(t.scheduledStart)):null};
          if(t.scheduledStart){
            t.scheduledStart = s.toISOString();
          } else {
            t.dayLock = toKey(s);
          }
          t._missed = true;
          return {...t};
        }));
      }

      function exportICS(){
        let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//Chaos Control//EN\n";
        for(const t of tasks){
          if(!t.scheduledStart) continue;
          const start = new Date(t.scheduledStart);
          const end = endTime(start, t.duration);
          const dt = (d)=> (
            d.getUTCFullYear().toString() +
            pad(d.getUTCMonth()+1) + pad(d.getUTCDate()) + "T" +
            pad(d.getUTCHours()) + pad(d.getUTCMinutes()) + "00Z"
          );
          ics += "BEGIN:VEVENT\n";
          ics += "UID:" + t.id + "@chaos-control\n";
          ics += "DTSTAMP:" + dt(new Date()) + "\n";
          ics += "DTSTART:" + dt(start) + "\n";
          ics += "DTEND:" + dt(end) + "\n";
          ics += "SUMMARY:" + (t.priority===1?"[HIGH] ":"") + t.title.replace(/\n/g," ") + "\n";
          ics += "END:VEVENT\n";
        }
        ics += "END:VCALENDAR\n";
        const blob = new Blob([ics], {type:"text/calendar"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "chaos-control-schedule.ics"; a.click();
        URL.revokeObjectURL(url);
      }

      function Header(){
        return (
          <header className="hdr">
            <div className="title">
              <span className="word-chaos">
                <span className="bomb-bg" aria-hidden="true"></span>
                Chaos
              </span>{" "}
              Control ‚Äî Smart Scheduler
            </div>
            <div className="hdr-tools">
              <input className="search" placeholder="üîç Search tasks‚Ä¶ (try: high, missed, Oct 23)"
                value={search} onChange={(e)=>setSearch(e.target.value)} />
              <button className="btn" onClick={()=>setShowDatePicker(v=>!v)} title="Pick a date">üìÖ</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, -7*1440))} title="Prev week">¬´ Wk</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, -1*1440))} title="Prev day">‚Äπ Day</button>
              <button className="btn primary" onClick={()=>setAnchorDate(startOfWeek(startOfDay(new Date()), settings.weekStartsOn))} title="Today">Today</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, 1*1440))} title="Next day">Day ‚Ä∫</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, 7*1440))} title="Next week">Wk ¬ª</button>
              <button className="btn" onClick={exportICS} title="Export .ics">üì§</button>
            </div>
            {showDatePicker && (
              <div className="date-picker">
                <input type="date" onChange={(e)=>{
                  if(e.target.value){ const d = parseKey(e.target.value); setAnchorDate(startOfWeek(d, settings.weekStartsOn)); setShowDatePicker(false); }
                }}/>
              </div>
            )}
          </header>
        );
      }

      function AddBar(){
        const ref = useRef();
        return (
          <form className="addbar" onSubmit={(e)=>{
            e.preventDefault();
            const data = new FormData(e.currentTarget);
            addTaskFromForm(data);
            e.currentTarget.reset();
            ref.current?.blur();
          }}>
            <input ref={ref} className="addbar-title" name="title" placeholder="‚ûï Add a new task‚Ä¶" />
            <div className="addbar-row">
              <label>Duration</label>
              <input type="number" name="dur_h" min="0" defaultValue="1" className="w80"/> hr
              <input type="number" name="dur_m" min="0" max="55" step="5" defaultValue="0" className="w80"/> min
              <label>Priority</label>
              <select name="priority" defaultValue="2">
                <option value="1">High</option>
                <option value="2">Medium</option>
                <option value="3">Low</option>
              </select>
              <label>When</label>
              <span className="seg">
                <label><input type="radio" name="mode" value="flex" defaultChecked/> Flexible</label>
                <label><input type="radio" name="mode" value="fixed"/> Fixed</label>
              </span>
              <span className="seg">
                <label><input type="radio" name="flex_preset" value="today" defaultChecked/> Today</label>
                <label><input type="radio" name="flex_preset" value="next2"/> Next 2d</label>
                <label><input type="radio" name="flex_preset" value="thisweek"/> This week</label>
                <label><input type="radio" name="flex_preset" value="by"/> By date</label>
                <input type="date" name="flex_by" className="w140"/>
              </span>
              <span className="seg">
                <label>Fixed date</label>
                <input type="date" name="fixed_date" className="w140"/>
                <label>time</label>
                <input type="time" name="fixed_time" className="w120"/>
              </span>
              <label>Calendar</label>
              <select name="calendar" defaultValue="work">
                <option value="work">Work</option>
                <option value="team">Team</option>
                <option value="personal">Home</option>
              </select>
              <button className="btn primary" type="submit">Add</button>
              <button className="btn" type="button" onClick={()=>autoSchedule(false)}>Auto-Schedule</button>
              <button className="btn" type="button" onClick={clearSchedules}>Clear</button>
            </div>
          </form>
        );
      }

      function TaskCard({t}){
        const color = calmap[t.calendar]?.color || "#334155";
        return (
          <div className={"taskcard" + (t.priority===1?" high":"") + (t._missed?" missed":"")} style={{borderColor: color}}>
            <div className="row">
              <label className="chk"><input type="checkbox" checked={!!t.done} onChange={()=>toggleDone(t.id)} /> Done</label>
              <div className="ttl">{t.title}</div>
              <div className="meta">
                <span>{t.duration} min</span>
                <span>{t.priority===1?"High":t.priority===3?"Low":"Med"}</span>
                {t._missed && <span className="badge">Missed</span>}
              </div>
            </div>
            {t._original && <div className="orig">Originally {t._original.date}{t._original.time?(" ‚Ä¢ "+t._original.time):""}</div>}
            <div className="row right">
              <button className="btn sm" onClick={()=>rescheduleTask(t.id, 1)}>+1 day</button>
              <button className="btn sm" onClick={()=>rescheduleTask(t.id, 2)}>+2 days</button>
              <button className="btn sm" onClick={()=>rescheduleTask(t.id, 7)}>+1 week</button>
            </div>
          </div>
        );
      }

      function DayColumn({day}){
        const dayKey = toKey(day);
        const busy = busyBlocksOnDay(day);
        const used = busy.reduce((s,b)=>s+b.duration,0);
        const cap = settings.dailyCapacityMins;
        const pct = Math.min(100, Math.round((used/cap)*100));
        const holidayName = holidayMap().get(dayKey);

        const unscheduled = tasks.filter(t => !t.scheduledStart && !t.done && matchesSearch(t) &&
          (!t.dayLock || t.dayLock===dayKey) &&
          (!t.windowStart || dayKey>=t.windowStart) &&
          (!t.windowEnd || dayKey<=t.windowEnd) &&
          t.dueDate <= dayKey
        ).sort((a,b)=> a.priority-b.priority || (a.dueDate>b.dueDate?1:-1));

        return (
          <div className={"daycol" + (dayKey===toKey(startOfDay(new Date()))?" today":"") + (holidayName?" holiday":"")}>
            <div className="dayhdr">
              <div className="dname">{day.toLocaleDateString(undefined,{weekday:"short"})}</div>
              <div className="dnum">{day.getDate()}</div>
              <div className="cap"><span style={{width:pct+"%"}}/></div>
              {holidayName && <div className="holiday-name" title="Alberta Stat Holiday">{holidayName}</div>}
            </div>
            <div className="busy">
              {busy.map((b,i)=>{
                const color = calmap[b.calendar]?.color || "#334155";
                const isTask = b.type==="task";
                return (
                  <div key={i} className={"busyitem"+(isTask?(b.t.priority===1?" high":""):"")+(isTask && b.t._missed?" missed":"")}
                       style={{borderColor: color, backgroundColor: color+"22"}}>
                    <div className="row">
                      <div className="time">{humanTime(b.start)}‚Äì{humanTime(endTime(b.start, b.duration))}</div>
                      {isTask && (
                        <label className="chk"><input type="checkbox" checked={!!b.t.done} onChange={()=>toggleDone(b.t.id)} /> Done</label>
                      )}
                    </div>
                    <div className="ttl">{b.title}</div>
                    {isTask && b.t._original && <div className="orig">Originally {b.t._original.date}{b.t._original.time?(" ‚Ä¢ "+b.t._original.time):""}</div>}
                    {isTask && (
                      <div className="row right">
                        <button className="btn xs" onClick={()=>rescheduleTask(b.t.id, 1)}>+1d</button>
                        <button className="btn xs" onClick={()=>rescheduleTask(b.t.id, 2)}>+2d</button>
                        <button className="btn xs" onClick={()=>rescheduleTask(b.t.id, 7)}>+1w</button>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>

            {unscheduled.length>0 && (
              <div className="unsched">
                <div className="unsched-h">Unscheduled eligible today</div>
                {unscheduled.map(t => <TaskCard key={t.id} t={t} />)}
              </div>
            )}
          </div>
        );
      }

      const unscheduledGlobal = tasks.filter(t => !t.scheduledStart && !t.done && matchesSearch(t));

      return (
        <div className="wrap">
          <Header/>
          <AddBar/>

          <div className="layout">
            <aside className="left">
              <div className="panel">
                <div className="panel-h">üóíÔ∏è Unscheduled Tasks</div>
                {unscheduledGlobal.length===0 ? (
                  <div className="empty">Nothing here ‚Äî everything else is on the calendar.</div>
                ) : (
                  unscheduledGlobal.map(t => <TaskCard key={t.id} t={t}/>)
                )}
              </div>

              <div className="panel">
                <div className="panel-h">Settings</div>
                <div className="row">
                  <label>Workday</label>
                  <input type="time" value={`${String(Math.floor(settings.workStartMins/60)).padStart(2,"0")}:${String(settings.workStartMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{
                      const [h,m]=e.target.value.split(":").map(Number);
                      setSettings(s=>({...s, workStartMins: h*60+m}));
                    }}/>
                  <span>‚Äì</span>
                  <input type="time" value={`${String(Math.floor(settings.workEndMins/60)).padStart(2,"0")}:${String(settings.workEndMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{
                      const [h,m]=e.target.value.split(":").map(Number);
                      setSettings(s=>({...s, workEndMins: h*60+m}));
                    }}/>
                </div>
                <div className="row">
                  <label>Tone</label>
                  <select value={settings.tone} onChange={(e)=>setSettings(s=>({...s, tone:e.target.value}))}>
                    <option value="mild">Mild Spice</option>
                    <option value="chaos">Full Chaos</option>
                    <option value="random">Surprise me</option>
                  </select>
                </div>
                <div className="row">
                  <label>Theme</label>
                  <select value={settings.theme} onChange={(e)=>setSettings(s=>({...s, theme:e.target.value}))}>
                    <option value="auto">Auto</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                  </select>
                </div>
                <div className="row">
                  <button className="btn" onClick={()=>autoSchedule(false)}>Auto-Schedule All</button>
                </div>
              </div>
            </aside>

            <main className="main">
              <div className="week">
                {weekDays.map(d => <DayColumn key={d.toISOString()} day={d}/>)}
              </div>
            </main>
          </div>

          {showSnark && (
            <div className="toast" onClick={()=>setShowSnark(null)}>
              <div className="star">‚≠ê</div>
              <div className="msg">{showSnark.msg}</div>
            </div>
          )}

          <footer className="ftr">Chaos Control v3 ‚Ä¢ for <strong>dysfunctional adults managing total chaos</strong>.</footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(<App/>);
  </script>
</body>
</html>
