<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chaos Control — Smart Scheduler v3.1</title>
  <link rel="stylesheet" href="styles.css"/>
  <!-- React & Babel from CDN for zero-build deploy -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <script type="text/babel">
    const {useState, useEffect, useMemo, useRef} = React;

    /* ---------- Utilities ---------- */
    const pad = (n) => String(n).padStart(2, "0");
    const minutes = (h, m=0) => h*60 + m;
    const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
    const addMinutes = (date, mins) => { const d=new Date(date); d.setMinutes(d.getMinutes()+mins); return d; };
    const toKey = (d) => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    const parseKey = (s) => { const [y,m,d]=s.split("-").map(Number); return new Date(y, m-1, d); };
    const startOfDay = (d) => { const x=new Date(d); x.setHours(0,0,0,0); return x; };
    const endOfDay = (d) => { const x=new Date(d); x.setHours(23,59,59,999); return x; };
    const startOfWeek = (d, weekStartsOn=1) => { const x=new Date(d); const day=(x.getDay()+7-weekStartsOn)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x; };
    const humanTime = (d) => `${pad(d.getHours())}:${pad(d.getMinutes())}`;
    const endTime = (start, dur) => addMinutes(start, dur);
    const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));

    /* ---------- Local Storage ---------- */
    const LS_TASKS="cc_tasks_v31";
    const LS_BLOCKS="cc_blocks_v31";
    const LS_SETTINGS="cc_settings_v31";
    const load = (k,fb) => { try { const raw=localStorage.getItem(k); return raw?JSON.parse(raw):fb } catch { return fb } };
    const save = (k,v) => { try { localStorage.setItem(k, JSON.stringify(v)) } catch {} };

    /* ---------- Alberta Holidays (current + next year) ---------- */
    function easterDate(year){
      const a = year % 19, b = Math.floor(year / 100), c = year % 100, d = Math.floor(b / 4), e = b % 4;
      const f = Math.floor((b + 8) / 25), g = Math.floor((b - f + 1) / 3);
      const h = (19*a + b - d - g + 15) % 30, i = Math.floor(c / 4), k = c % 4;
      const l = (32 + 2*e + 2*i - h - k) % 7, m = Math.floor((a + 11*h + 22*l) / 451);
      const month = Math.floor((h + l - 7*m + 114) / 31), day = ((h + l - 7*m + 114) % 31) + 1;
      return new Date(year, month-1, day);
    }
    function nthDowOfMonth(year, monthIndex, dow, n){
      const first = new Date(year, monthIndex, 1);
      const firstDow = first.getDay();
      const offset = (dow - firstDow + 7) % 7;
      const date = 1 + offset + (n-1)*7;
      return new Date(year, monthIndex, date);
    }
    function lastDowBefore(year, monthIndex, dayLimit, dow){
      const d = new Date(year, monthIndex, dayLimit);
      while (d.getDay() !== dow) d.setDate(d.getDate()-1);
      return d;
    }
    function albertaHolidaysForYear(year){
      const list = [];
      const push = (d, name) => list.push({date: toKey(d), name});
      push(new Date(year,0,1), "New Year's Day");
      push(nthDowOfMonth(year,1,1,3), "Family Day");
      const easter = easterDate(year);
      const goodFriday = new Date(easter); goodFriday.setDate(easter.getDate()-2);
      push(goodFriday, "Good Friday");
      push(lastDowBefore(year,4,24,1), "Victoria Day");
      push(new Date(year,6,1), "Canada Day");
      push(nthDowOfMonth(year,8,1,1), "Labour Day");
      push(new Date(year,8,30), "National Day for Truth and Reconciliation");
      push(nthDowOfMonth(year,9,1,2), "Thanksgiving");
      push(new Date(year,10,11), "Remembrance Day");
      push(new Date(year,11,25), "Christmas Day");
      push(new Date(year,11,26), "Boxing Day");
      return list;
    }
    function holidayMap(){
      const y = new Date().getFullYear();
      const all = [...albertaHolidaysForYear(y), ...albertaHolidaysForYear(y+1)];
      const m = new Map();
      all.forEach(h => m.set(h.date, h.name));
      return m;
    }

    /* ---------- Smart-Ass messages ---------- */
    const SNARK_MILD = [
      "Well look at you, functioning adult of the year.",
      "Everything done? I’m as shocked as you are.",
      "Achievement unlocked: Did the bare minimum, but in style.",
      "The productivity gods are appeased… for now.",
      "Chaos temporarily under control. Carry on."
    ];
    const SNARK_CHAOS = [
      "Everything done? Who kidnapped you and replaced you with someone responsible?",
      "You finished *everything*? Screenshot it before reality reloads.",
      "Task list annihilated. Chaos 0 – You 1.",
      "Achievement unlocked: Temporary competence.",
      "Your to-do list just filed for unemployment."
    ];

    /* ---------- Smarter duplicate detection ---------- */
    const STOP = new Set("the,a,an,and,or,for,to,of,in,on,at,by,with,from,as,is,are,be,was,were,do,does,did,this,that,these,those,my,our,your,their".split(","));
    function tokens(s){
      return (s||"").toLowerCase().replace(/[^a-z0-9\s-]/g," ").split(/\s+/).filter(w=>w && !STOP.has(w));
    }
    function jaccard(a,b){
      const A=new Set(tokens(a)), B=new Set(tokens(b));
      if(A.size===0 || B.size===0) return 0;
      let inter=0; for(const w of A) if(B.has(w)) inter++;
      return inter / (A.size + B.size - inter);
    }
    function leadingNum(s){ const m = (s||"").match(/^\s*(\d{3,})/); return m?m[1]:null; }
    function isLikelyDuplicate(titleA, titleB){
      const numA = leadingNum(titleA), numB = leadingNum(titleB);
      const sameNum = (numA && numB && numA===numB);
      const sim = jaccard(titleA, titleB);
      return sameNum || sim >= 0.58;
    }

    /* ---------- App ---------- */
    function App(){
      const holi = useMemo(()=>holidayMap(), []);
      const today = startOfDay(new Date());

      const [settings, setSettings] = useState(()=>load(LS_SETTINGS, {
        workStartMins: minutes(9,0),
        workEndMins: minutes(17,0),
        slotSize: 30,
        weekStartsOn: 1,
        dailyCapacityMins: 7*60,
        bufferMins: 5,
        preferMornings: true,
        tone: "mild",
        theme: "auto"
      }));
      const [tasks, setTasks] = useState(()=>load(LS_TASKS, []));
      const [blocks, setBlocks] = useState(()=>load(LS_BLOCKS, []));
      const [anchorDate, setAnchorDate] = useState(()=> startOfWeek(today, settings.weekStartsOn));
      const [search, setSearch] = useState("");
      const [showSnark, setShowSnark] = useState(null);

      const [editor, setEditor] = useState(null);
      const [dragTaskId, setDragTaskId] = useState(null);

      useEffect(()=>save(LS_SETTINGS, settings), [settings]);
      useEffect(()=>save(LS_TASKS, tasks), [tasks]);
      useEffect(()=>save(LS_BLOCKS, blocks), [blocks]);

      // Theme
      useEffect(()=>{
        const preferDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dark = settings.theme === "dark" || (settings.theme==="auto" && preferDark);
        document.documentElement.classList.toggle("dark", dark);
      }, [settings.theme]);

      // On load: move missed forward (pinned/fixed) & jump to this week
      useEffect(()=>{
        setTasks(prev => {
          const next = prev.map(t=>({...t}));
          const nowKey = toKey(today);
          for(const t of next){
            if(t.done) continue;
            if(t.scheduledStart){
              const s = new Date(t.scheduledStart);
              if(toKey(s) < nowKey){
                t._original = t._original || { date: toKey(s), time: humanTime(s) };
                t.scheduledStart = addMinutes(today, settings.workStartMins).toISOString();
                t._missed = true;
              }
              continue;
            }
            if(t.dayLock && t.dayLock < nowKey){
              t._original = t._original || { date: t.dayLock, time: null };
              t.dayLock = toKey(today);
              t._missed = true;
            }
          }
          return next;
        });
        setAnchorDate(startOfWeek(today, settings.weekStartsOn));
      }, []);

      const weekDays = useMemo(()=> Array.from({length:7}, (_,i)=> addMinutes(anchorDate, i*1440)), [anchorDate]);
      const todayKey = toKey(today);

      // Search
      const searchTokens = useMemo(()=> search.trim().toLowerCase().split(/\s+/).filter(Boolean), [search]);
      function matchesSearch(t){
        if(searchTokens.length===0) return true;
        const hay = [
          t.title || "",
          (t.notes||""),
          (t.calendar||""),
          t.priority===1?"high":t.priority===3?"low":"medium",
          t.done?"done":"",
          t._missed?"missed":"",
          t.scheduledStart?toKey(new Date(t.scheduledStart)):(t.dayLock||""),
        ].join(" ").toLowerCase();
        return searchTokens.every(tok => hay.includes(tok));
      }

      // Build blocks for a day, sort with done at bottom
      function busyBlocksOnDay(dayDate){
        const dayKey = toKey(dayDate);
        const busy = [];
        for(const t of tasks){
          if(!t.scheduledStart) continue;
          const s = new Date(t.scheduledStart);
          if(toKey(s)===dayKey) busy.push({start:s, duration:t.duration, title:t.title, type:"task", t});
        }
        busy.sort((a,b)=>{
          const aDone = a.type==="task" ? !!a.t.done : false;
          const bDone = b.type==="task" ? !!b.t.done : false;
          if(aDone !== bDone) return aDone ? 1 : -1; // done to bottom
          return a.start - b.start;
        });
        return busy;
      }

      // Auto-scheduler
      function autoSchedule(){
        setTasks(prev=>{
          const next = prev.map(t=>({...t, _moved:false}));
          const workStart = settings.workStartMins, workEnd=settings.workEndMins;
          const slot = settings.slotSize, buffer=settings.bufferMins;

          function canPlace(start, dur, dayBusy){
            for(const b of dayBusy){
              const A1 = start.getTime() - buffer*60000;
              const A2 = A1 + (dur + buffer*2)*60000;
              const B1 = b.start.getTime() - buffer*60000;
              const B2 = B1 + (b.duration + buffer*2)*60000;
              if(A1 < B2 && B1 < A2) return false;
            }
            return true;
          }

          const candidates = next
            .filter(t=>!t.done)
            .sort((a,b)=> a.priority-b.priority || (a.dueDate>b.dueDate?1:-1));

          for(const t of candidates){
            const rangeStart = t.dayLock ? parseKey(t.dayLock) : (t.windowStart? parseKey(t.windowStart): startOfDay(new Date()));
            const rangeEnd = t.dayLock ? parseKey(t.dayLock) : (t.windowEnd? parseKey(t.windowEnd): parseKey(t.dueDate));
            let placed = !!t.scheduledStart;
            if(t.scheduledStart && !t.flexible && !t._missed) continue;

            const days = Math.max(1, Math.ceil((endOfDay(rangeEnd)-startOfDay(rangeStart))/86400000)+1);
            for(let d=0; d<days && !placed; d++){
              const day = addMinutes(rangeStart, d*1440);
              const busy = busyBlocksOnDay(day);
              const used = busy.reduce((s,b)=>s+b.duration,0);
              if(used + t.duration > settings.dailyCapacityMins) continue;

              const order = [];
              for(let m=workStart; m + t.duration <= workEnd; m += slot) order.push(m);
              if(!settings.preferMornings) order.reverse();

              for(const m of order){
                const start = addMinutes(day, m);
                if(canPlace(start, t.duration, busy)){
                  t.scheduledStart = start.toISOString();
                  t._moved = true;
                  placed = true;
                  break;
                }
              }
            }
          }
          return next;
        });
      }
      function clearSchedules(){ setTasks(prev=>prev.map(t=>({...t, scheduledStart:null, _moved:false}))); }

      // Chime + gold star toast when all of TODAY’s tasks are done
      function playChime(){
        try{
          const ctx = new (window.AudioContext||window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine";
          o.frequency.value = 880; // A5
          g.gain.value = 0.001;
          o.connect(g); g.connect(ctx.destination);
          o.start();
          const now = ctx.currentTime;
          g.gain.exponentialRampToValueAtTime(0.03, now+0.02);
          o.frequency.exponentialRampToValueAtTime(1320, now+0.15);
          g.gain.exponentialRampToValueAtTime(0.00001, now+0.6);
          o.stop(now+0.65);
        }catch(e){}
      }
      function toggleDone(id){
        setTasks(prev=>{
          const next = prev.map(t=> t.id===id ? ({...t, done:!t.done}) : t);
          setTimeout(()=>{
            const todayKeyNow = toKey(startOfDay(new Date()));
            const todays = next.filter(t=> t.scheduledStart && toKey(new Date(t.scheduledStart))===todayKeyNow);
            const allDone = todays.length>0 && todays.every(t=>t.done);
            if(allDone){
              const pool = settings.tone==="random" ? [...SNARK_MILD, ...SNARK_CHAOS] :
                           settings.tone==="chaos" ? SNARK_CHAOS : SNARK_MILD;
              const msg = pool[Math.floor(Math.random()*pool.length)];
              setShowSnark({msg});
              confettiBurst();
              playChime();
            }
          }, 50);
          return next;
        });
      }
      function confettiBurst(){
        const root = document.body;
        for(let i=0;i<40;i++){
          const s = document.createElement('span');
          s.className = 'confetti';
          s.style.left = Math.random()*100 + '%';
          s.style.animationDelay = (Math.random()*0.4)+'s';
          root.appendChild(s);
          setTimeout(()=>root.removeChild(s), 2500);
        }
      }

      /* ---------- Add Task (with duplicate warning) ---------- */
      function addTaskFromForm(data){
        const title = (data.get("title")||"").toString().trim();
        if(!title) return alert("Please enter a task title.");
        const durH = parseInt((data.get("dur_h")||"0"),10)||0;
        const durM = parseInt((data.get("dur_m")||"0"),10)||0;
        const duration = clamp(durH*60 + durM || 30, 5, 24*60);
        const priority = parseInt((data.get("priority")||"2"),10)||2;
        const calendar = (data.get("calendar")||"work").toString();
        const mode = (data.get("mode")||"flex").toString();

        let flexible=true, windowStart=toKey(new Date()), windowEnd=toKey(new Date()), dayLock=null, scheduledStart=null, dueDate=windowEnd;
        if(mode==="flex"){
          const preset=(data.get("flex_preset")||"today").toString();
          const base = startOfDay(new Date());
          if(preset==="today"){ windowStart = toKey(base); windowEnd = toKey(base); }
          else if(preset==="next2"){ windowStart = toKey(base); windowEnd = toKey(addMinutes(base, 1440)); }
          else if(preset==="thisweek"){ windowStart = toKey(base); windowEnd = toKey(addMinutes(startOfWeek(base, settings.weekStartsOn), 6*1440)); }
          else { const by=(data.get("flex_by")||toKey(base)).toString(); windowStart=toKey(base); windowEnd=by; }
          dueDate = windowEnd;
        } else {
          flexible=false;
          const d = (data.get("fixed_date")||"").toString();
          const t = (data.get("fixed_time")||"").toString();
          dueDate = d || toKey(new Date());
          if(d && t) scheduledStart = new Date(`${d}T${t}:00`).toISOString();
          else if(d) dayLock = d;
        }

        const overlapCheck = (t) => {
          const sameFixed = (dayLock && t.dayLock && dayLock===t.dayLock);
          const sameDue   = (dueDate && t.dueDate && dueDate===t.dueDate);
          const overlapFlex = (!dayLock && !t.dayLock) && (windowStart<=t.windowEnd && t.windowStart<=windowEnd);
          return sameFixed || sameDue || overlapFlex;
        };
        const dups = tasks.filter(t => overlapCheck(t) && isLikelyDuplicate(title, t.title));
        if(dups.length){
          const names = dups.slice(0,3).map(d=>`• ${d.title}`).join("\n");
          const ok = confirm(`Heads up — this looks similar:\n${names}\n\nAdd anyway?`);
          if(!ok) return;
        }

        const newTask = {
          id: uid(), title, duration, priority, calendar,
          flexible, windowStart, windowEnd, dayLock, scheduledStart, dueDate,
          done:false, _moved:false, _missed:false
        };
        setTasks(prev=>[newTask, ...prev]);
      }

      /* ---------- Reschedule helpers ---------- */
      function rescheduleTask(id, days){
        setTasks(prev=>prev.map(t=>{
          if(t.id!==id) return t;
          let s = t.scheduledStart ? new Date(t.scheduledStart) : (t.dayLock? parseKey(t.dayLock) : startOfDay(new Date()));
          s.setDate(s.getDate()+days);
          t._original = t._original || {date: t.dayLock || (t.scheduledStart?toKey(new Date(t.scheduledStart)):null), time: t.scheduledStart?humanTime(new Date(t.scheduledStart)):null};
          if(t.scheduledStart){ t.scheduledStart = s.toISOString(); } else { t.dayLock = toKey(s); }
          t._missed = true;
          return {...t};
        }));
      }

      /* ---------- Header ---------- */
      function Header(){
        return (
          <header className="hdr">
            <div className="title">
              <span className="word-chaos"><span className="bomb-bg" aria-hidden="true"></span>Chaos</span> Control — Smart Scheduler
            </div>
            <div className="hdr-tools">
              <input className="search" placeholder="🔍 Search tasks… (e.g., high, missed, Oct 23)"
                value={search} onChange={(e)=>setSearch(e.target.value)} />
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, -7*1440))} title="Prev week">« Wk</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, -1*1440))} title="Prev day">‹ Day</button>
              <button className="btn primary" onClick={()=>setAnchorDate(startOfWeek(startOfDay(new Date()), settings.weekStartsOn))} title="Go to today">Today</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, 1*1440))} title="Next day">Day ›</button>
              <button className="btn" onClick={()=>setAnchorDate(addMinutes(anchorDate, 7*1440))} title="Next week">Wk »</button>
            </div>
          </header>
        );
      }

      /* ---------- Add Task Bar ---------- */
      function AddBar(){
        const ref = useRef();
        return (
          <form className="addbar" onSubmit={(e)=>{
            e.preventDefault();
            const data = new FormData(e.currentTarget);
            addTaskFromForm(data);
            e.currentTarget.reset();
            ref.current?.blur();
          }}>
            <input ref={ref} className="addbar-title" name="title" placeholder="➕ Add a new task…" />
            <div className="addbar-row">
              <label>Duration</label>
              <input type="number" inputMode="numeric" name="dur_h" min="0" defaultValue="1" className="w80"/> hr
              <input type="number" inputMode="numeric" name="dur_m" min="0" max="55" step="5" defaultValue="0" className="w80"/> min
              <label>Priority</label>
              <select name="priority" defaultValue="2">
                <option value="1">High</option>
                <option value="2">Medium</option>
                <option value="3">Low</option>
              </select>
              <label>When</label>
              <span className="seg">
                <label><input type="radio" name="mode" value="flex" defaultChecked/> Flexible</label>
                <label><input type="radio" name="mode" value="fixed"/> Fixed</label>
              </span>
              <span className="seg">
                <label><input type="radio" name="flex_preset" value="today" defaultChecked/> Today</label>
                <label><input type="radio" name="flex_preset" value="next2"/> Next 2d</label>
                <label><input type="radio" name="flex_preset" value="thisweek"/> This week</label>
                <label><input type="radio" name="flex_preset" value="by"/> By date</label>
                <input type="date" name="flex_by" className="w140"/>
              </span>
              <span className="seg">
                <label>Fixed date</label>
                <input type="date" name="fixed_date" className="w140"/>
                <label>time</label>
                <input type="time" name="fixed_time" className="w120"/>
              </span>
              <label>Calendar</label>
              <select name="calendar" defaultValue="work">
                <option value="work">Work</option>
                <option value="team">Team</option>
                <option value="personal">Home</option>
              </select>
              <button className="btn primary" type="submit">Add</button>
              <button className="btn" type="button" onClick={autoSchedule}>Auto-Schedule</button>
              <button className="btn" type="button" onClick={clearSchedules}>Clear</button>
            </div>
          </form>
        );
      }

      /* ---------- Task editor modal ---------- */
      function openEditorFor(t){
        const dur_h = Math.floor((t.duration||60)/60);
        const dur_m = (t.duration||60) % 60;
        const mode = t.flexible ? "flex" : "fixed";
        setEditor({
          id:t.id, title:t.title||"", dur_h, dur_m,
          priority:String(t.priority||2),
          calendar:t.calendar||"work",
          mode,
          flexPreset:"today",
          flex_by: t.windowEnd || toKey(new Date()),
          fixed_date: t.dayLock || (t.scheduledStart ? toKey(new Date(t.scheduledStart)) : ""),
          fixed_time: t.scheduledStart ? `${pad(new Date(t.scheduledStart).getHours())}:${pad(new Date(t.scheduledStart).getMinutes())}` : "",
          done: !!t.done
        });
      }
      function saveEditor(){
        setTasks(prev=>prev.map(t=>{
          if(!editor || t.id!==editor.id) return t;
          const duration = clamp((parseInt(editor.dur_h||0)*60 + parseInt(editor.dur_m||0)), 5, 24*60);
          let flexible=true, windowStart=toKey(new Date()), windowEnd=toKey(new Date()), dayLock=null, scheduledStart=null, dueDate=windowEnd;

          if(editor.mode==="flex"){
            const base=startOfDay(new Date());
            const preset=editor.flexPreset||"today";
            if(preset==="today"){ windowStart=toKey(base); windowEnd=toKey(base); }
            else if(preset==="next2"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(base,1440)); }
            else if(preset==="thisweek"){ windowStart=toKey(base); windowEnd=toKey(addMinutes(startOfWeek(base, settings.weekStartsOn), 6*1440)); }
            else { windowStart=toKey(base); windowEnd=editor.flex_by || toKey(base); }
            dueDate = windowEnd;
          } else {
            flexible=false;
            const d = editor.fixed_date || "";
            const tm = editor.fixed_time || "";
            dueDate = d || t.dueDate;
            if(d && tm){ scheduledStart = new Date(`${d}T${tm}:00`).toISOString(); }
            else if(d){ dayLock = d; }
          }

          return {
            ...t,
            title:editor.title.trim()||t.title,
            duration,
            priority:parseInt(editor.priority||"2",10)||2,
            calendar:editor.calendar||t.calendar,
            flexible, windowStart, windowEnd, dayLock, scheduledStart, dueDate,
            done: !!editor.done
          };
        }));
        setEditor(null);
      }
      function deleteTask(id){ setTasks(prev=>prev.filter(t=>t.id!==id)); setEditor(null); }

      function ModalEditor(){
        if(!editor) return null;
        return (
          <div className="modal-backdrop" onClick={()=>setEditor(null)}>
            <div className="modal" onClick={(e)=>e.stopPropagation()}>
              <div className="mh">
                <div>Edit Task</div>
                <button className="btn" onClick={()=>setEditor(null)}>✖</button>
              </div>

              <div className="row"><input type="text" value={editor.title} onChange={e=>setEditor({...editor, title:e.target.value})} placeholder="Title" autoFocus/></div>

              <div className="row">
                <div style={{flex:1}}>
                  <label>Hours</label>
                  <input type="number" inputMode="numeric" min="0" value={editor.dur_h} onChange={e=>setEditor({...editor, dur_h:e.target.value})}/>
                </div>
                <div style={{flex:1}}>
                  <label>Minutes</label>
                  <input type="number" inputMode="numeric" min="0" max="55" step="5" value={editor.dur_m} onChange={e=>setEditor({...editor, dur_m:e.target.value})}/>
                </div>
              </div>

              <div className="row">
                <div style={{flex:1}}>
                  <label>Priority</label>
                  <select value={editor.priority} onChange={e=>setEditor({...editor, priority:e.target.value})}>
                    <option value="1">High</option><option value="2">Medium</option><option value="3">Low</option>
                  </select>
                </div>
                <div style={{flex:1}}>
                  <label>Calendar</label>
                  <select value={editor.calendar} onChange={e=>setEditor({...editor, calendar:e.target.value})}>
                    <option value="work">Work</option><option value="team">Team</option><option value="personal">Home</option>
                  </select>
                </div>
              </div>

              <div className="row">
                <div className="seg">
                  <label><input type="radio" checked={editor.mode==="flex"} onChange={()=>setEditor({...editor, mode:"flex"})}/> Flexible</label>
                  <label><input type="radio" checked={editor.mode==="fixed"} onChange={()=>setEditor({...editor, mode:"fixed"})}/> Fixed</label>
                </div>
              </div>

              {editor.mode==="flex" ? (
                <div className="row">
                  <div className="seg">
                    <label><input type="radio" name="fp" checked={editor.flexPreset==="today"} onChange={()=>setEditor({...editor, flexPreset:"today"})}/> Today</label>
                    <label><input type="radio" name="fp" checked={editor.flexPreset==="next2"} onChange={()=>setEditor({...editor, flexPreset:"next2"})}/> Next 2d</label>
                    <label><input type="radio" name="fp" checked={editor.flexPreset==="thisweek"} onChange={()=>setEditor({...editor, flexPreset:"thisweek"})}/> This week</label>
                    <label><input type="radio" name="fp" checked={editor.flexPreset==="by"} onChange={()=>setEditor({...editor, flexPreset:"by"})}/> By date</label>
                    <input type="date" value={editor.flex_by} onChange={e=>setEditor({...editor, flex_by:e.target.value})}/>
                  </div>
                </div>
              ) : (
                <div className="row">
                  <div style={{flex:1}}>
                    <label>Fixed date</label>
                    <input type="date" value={editor.fixed_date||""} onChange={e=>setEditor({...editor, fixed_date:e.target.value})}/>
                  </div>
                  <div style={{flex:1}}>
                    <label>time</label>
                    <input type="time" value={editor.fixed_time||""} onChange={e=>setEditor({...editor, fixed_time:e.target.value})}/>
                  </div>
                </div>
              )}

              <div className="row">
                <label className="chk"><input type="checkbox" checked={!!editor.done} onChange={e=>setEditor({...editor, done:e.target.checked})}/> Mark complete</label>
              </div>

              <div className="actions">
                <button className="btn danger" onClick={()=>deleteTask(editor.id)}>Delete</button>
                <button className="btn" onClick={()=>setEditor(null)}>Cancel</button>
                <button className="btn primary" onClick={saveEditor}>Save</button>
              </div>
            </div>
          </div>
        );
      }

      /* ---------- Day Column with Drag & Drop + Day Summary ---------- */
      function DayColumn({day}){
        const dayKey = toKey(day);
        const busy = busyBlocksOnDay(day);
        const used = busy.reduce((s,b)=> s + (b.type==="task" ? b.duration : 0), 0);
        const cap = settings.dailyCapacityMins;
        const pct = Math.min(100, Math.round((used/cap)*100));
        const holidayName = holi.get(dayKey);

        const hasTasks = busy.some(b=>b.type==="task");
        const allDone = hasTasks && busy.filter(b=>b.type==="task").every(b=>b.t.done);

        const unscheduled = tasks.filter(t => !t.scheduledStart && !t.done && matchesSearch(t) &&
          (!t.dayLock || t.dayLock===dayKey) &&
          (!t.windowStart || dayKey>=t.windowStart) &&
          (!t.windowEnd || dayKey<=t.windowEnd) &&
          t.dueDate <= dayKey
        ).sort((a,b)=> a.priority-b.priority || (a.dueDate>b.dueDate?1:-1));

        const slot = settings.slotSize;
        const dayRectRef = useRef(null);
        const [dropY, setDropY] = useState(null);
        const [showSummary, setShowSummary] = useState(false);

        function nearestTimeFromClientY(clientY){
          const rect = dayRectRef.current?.getBoundingClientRect();
          if(!rect) return null;
          const y = Math.max(0, Math.min(clientY - rect.top, rect.height));
          const minsRange = settings.workEndMins - settings.workStartMins;
          const minutePerPixel = minsRange / rect.height;
          let mins = Math.round(y * minutePerPixel / slot) * slot;
          mins = Math.max(0, Math.min(mins, minsRange - slot));
          const when = addMinutes(startOfDay(day), settings.workStartMins + mins);
          return when;
        }
        function onDragOver(e){ if(dragTaskId){ e.preventDefault(); setDropY(e.clientY); } }
        function onDrop(e){
          if(!dragTaskId) return;
          e.preventDefault();
          const start = nearestTimeFromClientY(e.clientY);
          if(!start) return;
          setTasks(prev=>prev.map(t => t.id===dragTaskId ? ({...t, scheduledStart:start.toISOString(), dayLock:null, flexible:false, _missed:false}) : t));
          setDragTaskId(null); setDropY(null);
        }
        function onDragLeave(){ setDropY(null); }

        return (
          <div className={"daycol" + (dayKey===toKey(startOfDay(new Date()))?" today":"") + (holidayName?" holiday":"")}>
            {allDone && <div className="day-ribbon" title="All tasks done!"></div>}
            <div className="dayhdr" onClick={()=>setShowSummary(v=>!v)} style={{cursor:"pointer"}}>
              <div className="dname">{day.toLocaleDateString(undefined,{weekday:"short"})}</div>
              <div className="dnum">{day.getDate()}</div>
              <div className="cap"><span style={{width:pct+"%"}}/></div>
              {holidayName && <div className="holiday-name" title="Alberta Stat Holiday">{holidayName}</div>}
            </div>
            {showSummary && (
              <div className={"day-summary" + (pct>=100?" full":"")}>
                <div><strong>Scheduled:</strong> {used} min</div>
                <div><strong>Capacity used:</strong> {pct}%</div>
                <div><strong>Free:</strong> {Math.max(0, cap - used)} min</div>
              </div>
            )}

            <div
              className={"busy" + (dragTaskId?" drag-target":"")}
              ref={dayRectRef}
              onDragOver={onDragOver}
              onDrop={onDrop}
              onDragLeave={onDragLeave}
            >
              {dropY && <div className="drop-indicator" style={{ top: (dropY - (dayRectRef.current?.getBoundingClientRect()?.top||0)) + 'px' }} />}

              {busy.map((b,i)=>{
                const isTask = b.type==="task";
                return (
                  <div
                    key={i}
                    className={
                      "busyitem" +
                      (isTask?(b.t.priority===1?" high":""):"") +
                      (isTask && b.t._missed?" missed":"") +
                      (dragTaskId=== (isTask? b.t.id : null) ? " dragging" : "") +
                      (isTask && b.t.done ? " done" : "")
                    }
                    onClick={()=> isTask && openEditorFor(b.t)}
                    style={{cursor:isTask?"grab":"default"}}
                    draggable={isTask}
                    onDragStart={(e)=>{ if(isTask){ setDragTaskId(b.t.id); e.dataTransfer.setData("text/plain", b.t.id); } }}
                    onDragEnd={()=>{ setDragTaskId(null); setDropY(null); }}
                  >
                    <div className="row">
                      <div className="time">{humanTime(b.start)}–{humanTime(endTime(b.start, b.duration))}</div>
                      {isTask && (
                        <div className="row">
                          <label className="chk"><input type="checkbox" checked={!!b.t.done} onChange={(e)=>{e.stopPropagation(); toggleDone(b.t.id);}} /> Done</label>
                          <button className="btn xs" onClick={(e)=>{e.stopPropagation(); openEditorFor(b.t);}}>✏️</button>
                        </div>
                      )}
                    </div>
                    <div className="ttl">{b.title}</div>
                    {isTask && b.t._original && <div className="orig">Originally {b.t._original.date}{b.t._original.time?(" • "+b.t._original.time):""}</div>}
                    {isTask && (
                      <div className="row right">
                        <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id, 1);}}>+1d</button>
                        <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id, 2);}}>+2d</button>
                        <button className="btn xs" onClick={(e)=>{e.stopPropagation(); rescheduleTask(b.t.id, 7);}}>+1w</button>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>

            {unscheduled.length>0 && (
              <div className="unsched">
                <div className="unsched-h">Unscheduled eligible today</div>
                {unscheduled.map(t => <TaskCard key={t.id} t={t} />)}
              </div>
            )}
          </div>
        );
      }

      /* ---------- Left column + layout ---------- */
      const unscheduledGlobal = tasks.filter(t => !t.scheduledStart && !t.done && matchesSearch(t));

      return (
        <div className="wrap">
          <Header/>
          <AddBar/>

          <div className="layout">
            <aside className="left">
              <div className="panel">
                <div className="panel-h">🗒️ Unscheduled Tasks</div>
                {unscheduledGlobal.length===0 ? (
                  <div className="empty">Nothing here — everything else is on the calendar.</div>
                ) : (
                  unscheduledGlobal.map(t => <TaskCard key={t.id} t={t}/>)
                )}
              </div>

              <div className="panel">
                <div className="panel-h">Settings</div>
                <div className="row">
                  <label>Workday</label>
                  <input type="time" value={`${String(Math.floor(settings.workStartMins/60)).padStart(2,"0")}:${String(settings.workStartMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{ const [h,m]=e.target.value.split(":").map(Number); setSettings(s=>({...s, workStartMins: minutes(h,m)})); }}/>
                  <span>–</span>
                  <input type="time" value={`${String(Math.floor(settings.workEndMins/60)).padStart(2,"0")}:${String(settings.workEndMins%60).padStart(2,"0")}`}
                    onChange={(e)=>{ const [h,m]=e.target.value.split(":").map(Number); setSettings(s=>({...s, workEndMins: minutes(h,m)})); }}/>
                </div>
                <div className="row">
                  <label>Tone</label>
                  <select value={settings.tone} onChange={(e)=>setSettings(s=>({...s, tone:e.target.value}))}>
                    <option value="mild">Mild Spice</option>
                    <option value="chaos">Full Chaos</option>
                    <option value="random">Surprise me</option>
                  </select>
                </div>
                <div className="row">
                  <label>Theme</label>
                  <select value={settings.theme} onChange={(e)=>setSettings(s=>({...s, theme:e.target.value}))}>
                    <option value="auto">Auto</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                  </select>
                </div>
                <div className="row">
                  <button className="btn" onClick={autoSchedule}>Auto-Schedule All</button>
                </div>
              </div>
            </aside>

            <main className="main">
              <div className="week">
                {weekDays.map(d => <DayColumn key={d.toISOString()} day={d}/>)}
              </div>
            </main>
          </div>

          {showSnark && (
            <div className="toast" onClick={()=>setShowSnark(null)}>
              <div className="star">⭐</div>
              <div className="msg">{showSnark.msg}</div>
            </div>
          )}

          <footer className="ftr">Chaos Control v3.1 • for <strong>dysfunctional adults managing total chaos</strong>.</footer>

          {/* Modal at root */}
          <ModalEditor/>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(<App/>);
  </script>
</body>
</html>
